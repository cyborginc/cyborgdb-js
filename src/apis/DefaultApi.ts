/* tslint:disable */
/* eslint-disable */
/**
 * CyborgDB Service
 * REST API for CyborgDB: The Confidential Vector Database
 *
 * The version of the OpenAPI document: 0.12.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CreateIndexRequest,
  CyborgdbServiceApiSchemasIndexSuccessResponseModel,
  CyborgdbServiceApiSchemasVectorsSuccessResponseModel,
  DeleteRequest,
  ErrorResponseModel,
  GetRequest,
  GetResponseModel,
  HTTPValidationError,
  IndexInfoResponseModel,
  IndexListResponseModel,
  IndexOperationRequest,
  IndexTrainingStatusResponseModel,
  ListIDsRequest,
  ListIDsResponse,
  QueryResponse,
  Request,
  TrainRequest,
  UpsertRequest,
} from '../models/index';
import {
    CreateIndexRequestFromJSON,
    CreateIndexRequestToJSON,
    CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON,
    CyborgdbServiceApiSchemasIndexSuccessResponseModelToJSON,
    CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON,
    CyborgdbServiceApiSchemasVectorsSuccessResponseModelToJSON,
    DeleteRequestFromJSON,
    DeleteRequestToJSON,
    ErrorResponseModelFromJSON,
    ErrorResponseModelToJSON,
    GetRequestFromJSON,
    GetRequestToJSON,
    GetResponseModelFromJSON,
    GetResponseModelToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    IndexInfoResponseModelFromJSON,
    IndexInfoResponseModelToJSON,
    IndexListResponseModelFromJSON,
    IndexListResponseModelToJSON,
    IndexOperationRequestFromJSON,
    IndexOperationRequestToJSON,
    IndexTrainingStatusResponseModelFromJSON,
    IndexTrainingStatusResponseModelToJSON,
    ListIDsRequestFromJSON,
    ListIDsRequestToJSON,
    ListIDsResponseFromJSON,
    ListIDsResponseToJSON,
    QueryResponseFromJSON,
    QueryResponseToJSON,
    RequestFromJSON,
    RequestToJSON,
    TrainRequestFromJSON,
    TrainRequestToJSON,
    UpsertRequestFromJSON,
    UpsertRequestToJSON,
} from '../models/index';

export interface CreateIndexV1IndexesCreatePostRequest {
    createIndexRequest: CreateIndexRequest;
}

export interface DeleteIndexV1IndexesDeletePostRequest {
    indexOperationRequest: IndexOperationRequest;
}

export interface DeleteVectorsV1VectorsDeletePostRequest {
    deleteRequest: DeleteRequest;
}

export interface GetIndexInfoV1IndexesDescribePostRequest {
    indexOperationRequest: IndexOperationRequest;
}

export interface GetIndexSizeV1VectorsNumVectorsPostRequest {
    indexOperationRequest: IndexOperationRequest;
}

export interface GetVectorsV1VectorsGetPostRequest {
    getRequest: GetRequest;
}

export interface ListIdsV1VectorsListIdsPostRequest {
    listIDsRequest: ListIDsRequest;
}

export interface QueryVectorsV1VectorsQueryPostRequest {
    request: Request;
}

export interface TrainIndexV1IndexesTrainPostRequest {
    trainRequest: TrainRequest;
}

export interface UpsertVectorsV1VectorsUpsertPostRequest {
    upsertRequest: UpsertRequest;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create a new encrypted index with the provided configuration.
     * Create Encrypted Index
     */
    async createIndexV1IndexesCreatePostRaw(requestParameters: CreateIndexV1IndexesCreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasIndexSuccessResponseModel>> {
        if (requestParameters['createIndexRequest'] == null) {
            throw new runtime.RequiredError(
                'createIndexRequest',
                'Required parameter "createIndexRequest" was null or undefined when calling createIndexV1IndexesCreatePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/indexes/create`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CreateIndexRequestToJSON(requestParameters['createIndexRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Create a new encrypted index with the provided configuration.
     * Create Encrypted Index
     */
    async createIndexV1IndexesCreatePost(requestParameters: CreateIndexV1IndexesCreatePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasIndexSuccessResponseModel> {
        const response = await this.createIndexV1IndexesCreatePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete a specific index.
     * Delete Encrypted Index
     */
    async deleteIndexV1IndexesDeletePostRaw(requestParameters: DeleteIndexV1IndexesDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasIndexSuccessResponseModel>> {
        if (requestParameters['indexOperationRequest'] == null) {
            throw new runtime.RequiredError(
                'indexOperationRequest',
                'Required parameter "indexOperationRequest" was null or undefined when calling deleteIndexV1IndexesDeletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/indexes/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IndexOperationRequestToJSON(requestParameters['indexOperationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Delete a specific index.
     * Delete Encrypted Index
     */
    async deleteIndexV1IndexesDeletePost(requestParameters: DeleteIndexV1IndexesDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasIndexSuccessResponseModel> {
        const response = await this.deleteIndexV1IndexesDeletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete vectors by their IDs.
     * Delete Items from Encrypted Index
     */
    async deleteVectorsV1VectorsDeletePostRaw(requestParameters: DeleteVectorsV1VectorsDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasVectorsSuccessResponseModel>> {
        if (requestParameters['deleteRequest'] == null) {
            throw new runtime.RequiredError(
                'deleteRequest',
                'Required parameter "deleteRequest" was null or undefined when calling deleteVectorsV1VectorsDeletePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/delete`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DeleteRequestToJSON(requestParameters['deleteRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Delete vectors by their IDs.
     * Delete Items from Encrypted Index
     */
    async deleteVectorsV1VectorsDeletePost(requestParameters: DeleteVectorsV1VectorsDeletePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasVectorsSuccessResponseModel> {
        const response = await this.deleteVectorsV1VectorsDeletePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get information about a specific index.
     * Describe Encrypted Index
     */
    async getIndexInfoV1IndexesDescribePostRaw(requestParameters: GetIndexInfoV1IndexesDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexInfoResponseModel>> {
        if (requestParameters['indexOperationRequest'] == null) {
            throw new runtime.RequiredError(
                'indexOperationRequest',
                'Required parameter "indexOperationRequest" was null or undefined when calling getIndexInfoV1IndexesDescribePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/indexes/describe`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IndexOperationRequestToJSON(requestParameters['indexOperationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexInfoResponseModelFromJSON(jsonValue));
    }

    /**
     * Get information about a specific index.
     * Describe Encrypted Index
     */
    async getIndexInfoV1IndexesDescribePost(requestParameters: GetIndexInfoV1IndexesDescribePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexInfoResponseModel> {
        const response = await this.getIndexInfoV1IndexesDescribePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the number of vectors stored in an index
     * Get the number of vectors in an index
     */
    async getIndexSizeV1VectorsNumVectorsPostRaw(requestParameters: GetIndexSizeV1VectorsNumVectorsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasVectorsSuccessResponseModel>> {
        if (requestParameters['indexOperationRequest'] == null) {
            throw new runtime.RequiredError(
                'indexOperationRequest',
                'Required parameter "indexOperationRequest" was null or undefined when calling getIndexSizeV1VectorsNumVectorsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/num_vectors`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: IndexOperationRequestToJSON(requestParameters['indexOperationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Get the number of vectors stored in an index
     * Get the number of vectors in an index
     */
    async getIndexSizeV1VectorsNumVectorsPost(requestParameters: GetIndexSizeV1VectorsNumVectorsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasVectorsSuccessResponseModel> {
        const response = await this.getIndexSizeV1VectorsNumVectorsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the current training status including indexes being trained and the retrain threshold configuration.  Returns:     dict: Training status information including:         - training_indexes: List of index names currently being trained         - retrain_threshold: The multiplier used for the retraining threshold
     * Get Training Status
     */
    async getTrainingStatusV1IndexesTrainingStatusGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexTrainingStatusResponseModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/indexes/training-status`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexTrainingStatusResponseModelFromJSON(jsonValue));
    }

    /**
     * Get the current training status including indexes being trained and the retrain threshold configuration.  Returns:     dict: Training status information including:         - training_indexes: List of index names currently being trained         - retrain_threshold: The multiplier used for the retraining threshold
     * Get Training Status
     */
    async getTrainingStatusV1IndexesTrainingStatusGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexTrainingStatusResponseModel> {
        const response = await this.getTrainingStatusV1IndexesTrainingStatusGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve vectors by their IDs.
     * Get Items from Encrypted Index
     */
    async getVectorsV1VectorsGetPostRaw(requestParameters: GetVectorsV1VectorsGetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetResponseModel>> {
        if (requestParameters['getRequest'] == null) {
            throw new runtime.RequiredError(
                'getRequest',
                'Required parameter "getRequest" was null or undefined when calling getVectorsV1VectorsGetPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/get`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetRequestToJSON(requestParameters['getRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetResponseModelFromJSON(jsonValue));
    }

    /**
     * Retrieve vectors by their IDs.
     * Get Items from Encrypted Index
     */
    async getVectorsV1VectorsGetPost(requestParameters: GetVectorsV1VectorsGetPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetResponseModel> {
        const response = await this.getVectorsV1VectorsGetPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check if the API is running.
     * Health check endpoint
     */
    async healthCheckV1HealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: string; }>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/v1/health`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Check if the API is running.
     * Health check endpoint
     */
    async healthCheckV1HealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: string; }> {
        const response = await this.healthCheckV1HealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * List all item IDs currently stored in the index.  Returns a list of all IDs and the total count.
     * List all IDs in an index
     */
    async listIdsV1VectorsListIdsPostRaw(requestParameters: ListIdsV1VectorsListIdsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListIDsResponse>> {
        if (requestParameters['listIDsRequest'] == null) {
            throw new runtime.RequiredError(
                'listIDsRequest',
                'Required parameter "listIDsRequest" was null or undefined when calling listIdsV1VectorsListIdsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/list_ids`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ListIDsRequestToJSON(requestParameters['listIDsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListIDsResponseFromJSON(jsonValue));
    }

    /**
     * List all item IDs currently stored in the index.  Returns a list of all IDs and the total count.
     * List all IDs in an index
     */
    async listIdsV1VectorsListIdsPost(requestParameters: ListIdsV1VectorsListIdsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListIDsResponse> {
        const response = await this.listIdsV1VectorsListIdsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List all available indexes.
     * List Encrypted Indexes
     */
    async listIndexesV1IndexesListGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<IndexListResponseModel>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/indexes/list`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => IndexListResponseModelFromJSON(jsonValue));
    }

    /**
     * List all available indexes.
     * List Encrypted Indexes
     */
    async listIndexesV1IndexesListGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<IndexListResponseModel> {
        const response = await this.listIndexesV1IndexesListGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Search for nearest neighbors in the index.
     * Query Encrypted Index
     */
    async queryVectorsV1VectorsQueryPostRaw(requestParameters: QueryVectorsV1VectorsQueryPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryResponse>> {
        if (requestParameters['request'] == null) {
            throw new runtime.RequiredError(
                'request',
                'Required parameter "request" was null or undefined when calling queryVectorsV1VectorsQueryPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/query`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: RequestToJSON(requestParameters['request']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryResponseFromJSON(jsonValue));
    }

    /**
     * Search for nearest neighbors in the index.
     * Query Encrypted Index
     */
    async queryVectorsV1VectorsQueryPost(requestParameters: QueryVectorsV1VectorsQueryPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryResponse> {
        const response = await this.queryVectorsV1VectorsQueryPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Train the index for efficient querying.  Note: This endpoint triggers manual training. Automatic training is also triggered based on vector count thresholds after upserts.
     * Train Encrypted index
     */
    async trainIndexV1IndexesTrainPostRaw(requestParameters: TrainIndexV1IndexesTrainPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasIndexSuccessResponseModel>> {
        if (requestParameters['trainRequest'] == null) {
            throw new runtime.RequiredError(
                'trainRequest',
                'Required parameter "trainRequest" was null or undefined when calling trainIndexV1IndexesTrainPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/indexes/train`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TrainRequestToJSON(requestParameters['trainRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasIndexSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Train the index for efficient querying.  Note: This endpoint triggers manual training. Automatic training is also triggered based on vector count thresholds after upserts.
     * Train Encrypted index
     */
    async trainIndexV1IndexesTrainPost(requestParameters: TrainIndexV1IndexesTrainPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasIndexSuccessResponseModel> {
        const response = await this.trainIndexV1IndexesTrainPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Add or update vectors in the index.  After upserting, checks if the index needs training/retraining based on the number of vectors and triggers automatic training if needed.
     * Add Items to Encrypted Index
     */
    async upsertVectorsV1VectorsUpsertPostRaw(requestParameters: UpsertVectorsV1VectorsUpsertPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CyborgdbServiceApiSchemasVectorsSuccessResponseModel>> {
        if (requestParameters['upsertRequest'] == null) {
            throw new runtime.RequiredError(
                'upsertRequest',
                'Required parameter "upsertRequest" was null or undefined when calling upsertVectorsV1VectorsUpsertPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["X-API-Key"] = await this.configuration.apiKey("X-API-Key"); // APIKeyHeader authentication
        }

        const response = await this.request({
            path: `/v1/vectors/upsert`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UpsertRequestToJSON(requestParameters['upsertRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CyborgdbServiceApiSchemasVectorsSuccessResponseModelFromJSON(jsonValue));
    }

    /**
     * Add or update vectors in the index.  After upserting, checks if the index needs training/retraining based on the number of vectors and triggers automatic training if needed.
     * Add Items to Encrypted Index
     */
    async upsertVectorsV1VectorsUpsertPost(requestParameters: UpsertVectorsV1VectorsUpsertPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CyborgdbServiceApiSchemasVectorsSuccessResponseModel> {
        const response = await this.upsertVectorsV1VectorsUpsertPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
